
rename_sm <- function(x = NULL,
                      show.overview = FALSE,
                      bad.names = tidyverse_names,
                      outer.inner.sep = "_",
                      matrix.row.col.sep = ".",
                      name.component.repair = NULL,
                      others = "Other (please specify)",
                      n.options = 4,
                      n.row.col = 5,
                      verbose = FALSE){

  ### Get good bad.names

  stopifnot(!is.null(bad.names))
  if(!length(bad.names) == 1) stop("Argument bad.names should have length 1, not ", length(bad.names))

  if(is.character(bad.names)){
    if(verbose) message("Using bad.names as regex in stringr::str_detect")
    bad.names <- function(x) stringr::str_detect(x, bad.names)
  } else if (!is.function(bad.names)) stop("bad.names must be a character vector or predicate function, not an object of type ", typeof(bad.names), " .")

  ## By default, SM data stores question data in the first two rows
  ## of the response csv. This function assumes that the first row
  ## has been read as names, and the second row as the new first row
  nameOuters <- names(x)
  nameInners <- as.character(x[1,])
  responses <- x[-1,]

  ## bad.names predicate used to identify meaningless/duplicate names generated by name repair processes
  ## these are set to NA so that tidyr::fill can replace them with the 'good' name

    nameOuters[bad.names(nameOuters)] <- NA


  ## Use tidyr::fill to replace NAs with duplicates of nameOuters
  fillHelper <- tibble::tibble(outers = nameOuters) ## Need to borrow a tibble to do this
  fillHelper <- tidyr::fill(fillHelper, outers, .direction = "down")
  nameOuters <- fillHelper[["outers"]]
  rm(fillHelper)

  ## Intermediate nameData tibble will help to create a list structure
  nameData <- tibble::tibble(
    nameOuters = factor(nameOuters,
                        levels = unique(nameOuters),
                        ordered = TRUE), #order ensures question order is preserved in UI
    nameInners
  )
  rm(nameOuters, nameInners)

  ## Set nameInners to NA where SM has used question-type defaults - these inners tell us nothing useful
  nameData <- dplyr::mutate(nameData,
                            nameInners =
                              replace(nameInners,
                                      nameInners == "Response" | nameInners == "Open-Ended Response" | nameInners == "NA",
                                      NA))


  ## Label question types for further processing -------------------------------------------------------

  ### some functions and regex literals to help us extract string parts ::::::::::::::::::::::::::::::
  has_hyphen <- function(x) stringr::str_detect(x, "[:space:]-[:space:]")
  beforeTheHyphen <- "^.+(?=([:space:]-[:space:]))"
  afterTheHyphen <- "(?<=([:space:]-[:space:])).+$"

  ### get_resp_type function :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  #### Assign each question outer a type - one of c("singleResponse", "multipleResponses", "matrix")
  get_resp_type <- function(inner.fields){

    ## If there's only one possible response to this question, it's single response
    if(length(inner.fields) == 1) type <- "singleResponse"

    else if(!all(has_hyphen(inner.fields) | inner.fields %in% others)) type <- "multipleResponses"

    else {
      ## If all the inner fields have the hyphen syntax (or match the 'other' pattern),
      ### Check to see if it's a matrix

      assume <- TRUE

      inner.fields <- inner.fields[!inner.fields %in% others] #Ignore any 'other' fields

      ## If this is a matrix question it should be possible to pull apart the question names,
      ### then paste the row and col names together exhaustively in sequence in order to
      ### exactly reproduce the given names

      ### Split the innerNames in half (the rows and columns of the question matrix)
      beforeTheHyphen <- "^.+(?=([:space:]-[:space:]))"
      afterTheHyphen <- "(?<=([:space:]-[:space:])).+$"

      rowFields = stringr::str_extract(inner.fields, beforeTheHyphen)
      colFields = stringr::str_extract(inner.fields, afterTheHyphen)

      # uniqueRows <- dplyr::n_distinct(rowFields)
      uniqueRows <- unique(rowFields)
      uniqueCols <- unique(colFields)

      expectedQuestions <- apply(
        expand.grid(
          uniqueCols,
          uniqueRows
          ),
        1, function(x) paste(rev(x), collapse = " - ")
        )

      ### If the objects aren't identical, it's not a matrix question
      if(!identical(expectedQuestions, inner.fields)) assume <- FALSE
      if(assume) type <- "matrix"
      else type <- "multipleResponses"
    }
    type <- factor(type, levels = c("singleResponse", "multipleResponses", "matrix"),
                   ordered = FALSE)
    return(type)
  }

  nameData <- dplyr::group_by(nameData, nameOuters)
  nameData <- dplyr::mutate(nameData, responseType = get_resp_type(nameInners))

  nameData <- dplyr::mutate(nameData,
                            matrixRow = ifelse(responseType == "matrix", stringr::str_extract(nameInners, beforeTheHyphen), NA),
                            matrixCol = ifelse(responseType == "matrix", stringr::str_extract(nameInners, afterTheHyphen), NA))

  nameData <- dplyr::ungroup(nameData)
  nameData <- dplyr::mutate(nameData,
                            matrixRow = factor(matrixRow, ordered = TRUE),
                            matrixCol = factor(matrixCol, ordered = TRUE))

  nameData <- dplyr::mutate(nameData,
                                   matrixRow = factor(matrixRow, levels = rev(levels(matrixRow)), ordered = TRUE),
                                   matrixCol = factor(matrixCol, levels = rev(levels(matrixCol)), ordered = TRUE))

  nameData <- dplyr::arrange(nameData, matrixRow, matrixCol)

  nameData <- dplyr::group_by(nameData, nameOuters)



  ## Show an overview of all the questions if user wishes ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  print_overview <- function(outer.names = NULL, inner.names = NULL,
                             response.types = NULL,
                             matrix.rows = NULL, matrix.cols = NULL){



    cat("-----------------------------------------------------------------------------\n\n")
    cat("Current question name outer:", "\t")
    cat(unique(as.character(outer.names)),"\n\n")

    cat("Question type:\t")
    cat(unique(as.character(response.types)), "\n\n")

    if(all(response.types == "multipleResponses")){
      cat("Question options (1-", min(n.options,length(inner.names)), "):", "\n", sep = "")
      cat(as.character(inner.names)[1:min(n.options,length(inner.names))], "\n\n", sep = "\n")

    } else if (all(response.types == "matrix") && !is.null(matrix.rows) && !is.null(matrix.cols)){
      matrixRows <- unique(matrix.rows)
      matrixCols <- unique(matrix.cols)

      cat("Matrix rows:", "\n")

      make_printable <- function(x){
        x <- x[!is.na(x)]
        x <- x[1:min(n.row.col, length(x))]
        x <- as.character(x)
      }

      cat(make_printable(matrixRows), sep = "\n")
      cat("\n")
      cat("Matrix columns:", "\n")
      cat(make_printable(matrixCols), sep = "\n")

      cat("\n")
    } else {}
    return(NULL)
  }

  if(show.overview){
    ## Construct a list of tibbles, one for each 'nameOuter'
    overViewFrame <- dplyr::group_split(nameData)
    ## This is probably a silly way of doing this
  invisible(
    lapply(overViewFrame,
           function(x){
             rlang::eval_tidy(
               data = x,
               rlang::expr({
                  print_overview(
                     outer.names = nameOuters,
                     inner.names = nameInners,
                    response.types = responseType,
                    matrix.rows = NULL,
                     matrix.cols = NULL
                    )
               })
             )
           }
    )
  )
  }

## Get new outers from user ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  get_new_outer <- function(outer.names = NULL, ...){

    print_overview(outer.names = outer.names, ...)

    out <- readline("New outer name: ")
    return(out)
  }

  namingStructure <- dplyr::mutate(nameData,
                                   newOuterName =
                                     {
                                       get_new_outer(outer.names = nameOuters, inner.names = nameInners,
                                                     response.types = responseType,
                                                     matrix.rows = matrixRow, matrix.cols = matrixCol)
                                     })

### Make name inners (level above matrix row/cols) into order factor for consistent printing
  namingStructure <- dplyr::ungroup(namingStructure)
  namingStructure <- dplyr::mutate(namingStructure, nameInners = factor(nameInners, levels = unique(nameInners), ordered = TRUE))

  namingStructure <- dplyr::group_by(namingStructure, nameOuters, responseType, nameInners)


  get_new_inner <- function(new.outer.name = NULL,
                            inner.name = NULL,
                            response.type = NULL){

    if(response.type != "multipleResponses") out <- NA # Only want 'new' inner names for 'multipleResponse' type questions
    else {
      cat("-----------------------------------------------------------------------------\n\n")
      cat("Question outer (new):\t", new.outer.name, "\n")
      cat("Question inner (old):\t", as.character(inner.name), "\n\n")

      out <- readline("New question-inner name: ")
    }
    return(out)
  }

  namingStructure <- dplyr::mutate(namingStructure,
                                   newInner = get_new_inner(new.outer.name =  newOuterName,
                                                            inner.name = nameInners,
                                                            response.type = responseType))

  ### Rename matix rows and columns ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

  cat("\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n| Renaming matrix question rows |\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n")

  ##### Renaming rows:


  new_matrix_rows <- function(new.outer.name = NULL,
                              old.matrix.row = NULL,
                              response.type = NULL,
                              old.matrix.cols = NULL){

    matrixCols <- old.matrix.cols[!is.na(old.matrix.cols)]

    if(any(as.character(response.type) != "matrix")) out <- NA
    else if(is.na(unique(old.matrix.row))) out <- NA
    else {
      cat("--------------------------------------------------------------------\n\n")
      cat("Question outer (new):\t", unique(new.outer.name), "\n")
      cat("Matrix cols:\n\n")
      cat(as.character(matrixCols), sep = "\n")
      cat("\nCurrent matrix row name:", unique(as.character(old.matrix.row)), "\n\n")

      out <- readline("New matrix row name:")
    }
    return(out)
  }

  namingStructure <- dplyr::group_by(namingStructure, nameOuters, matrixRow, responseType)

  namingStructure <- dplyr::mutate(namingStructure,
                                   newMatrixRows =
                                     new_matrix_rows(new.outer.name = newOuterName,
                                                     old.matrix.row = matrixRow,
                                                     response.type = responseType,
                                                     old.matrix.cols = matrixCol)
                                   )
  rm(new_matrix_rows)

  namingStructure <- dplyr::group_by(namingStructure, nameOuters, matrixCol, responseType)

  new_matrix_cols <- function(new.outer.name = NULL,
                              old.matrix.col = NULL,
                              response.type = NULL,
                              new.matrix.rows = NULL){

    if(any(as.character(response.type) != "matrix")) out <- NA
    else if(is.na(unique(old.matrix.col))) out <- NA
    else {
      cat("--------------------------------------------------------------------\n\n")
      cat("Question outer (new):\t", unique(new.outer.name), "\n")
      cat("Matrix rows:\n\n")
      cat(new.matrix.rows, sep = "\n")
      cat("\nCurrent matrix col name:", unique(as.character(old.matrix.col)), "\n\n")

      out <- readline("New matrix col name:")
    }
    return(out)

  }

  namingStructure <- dplyr::mutate(namingStructure,
                                   newMatrixCols =
                                     new_matrix_cols(new.outer.name = newOuterName,
                                                     old.matrix.col = matrixCol,
                                                     response.type = responseType,
                                                     new.matrix.rows = newMatrixRows)
                                   )
  rm(new_matrix_cols)

  ## Join name components into full names
  namingStructure <- dplyr::ungroup(namingStructure)

  ### Apply name.component.repair to each component (if it's not null)
  across <- dplyr::across # less ugly
  if(!is.null(name.component.repair)){
    namingStructure <- dplyr::mutate(namingStructure, across(c(newOuterName, newInner, newMatrixRows, newMatrixCols),
                                                             name.component.repair))
  }

  ### Initialise new row 'outerInnerSep', used for joining values
  namingStructure[["outerInnerSep"]] <- NA

  namingStructure[["outerInnerSep"]][  ## outer.inner.sep is is assigned from formal when type is mulitple or matrix
    namingStructure[["responseType"]] %in% c("multipleResponses","matrix")
    ] <- outer.inner.sep

  ## Same as above, but for matix questions which have an additional separator
  namingStructure[["matrixRowColSep"]] <- NA
  namingStructure[["matrixRowColSep"]][namingStructure[["responseType"]] == "matrix"] <- matrix.row.col.sep

  ### Glue the name components together, assigning NAs a value of ""
  namingStructure <- dplyr::mutate(namingStructure,
                                   fullName =
                                     glue::glue("{newOuterName}{outerInnerSep}{newInner}{newMatrixRows}{matrixRowColSep}{newMatrixCols}",
                                                .na = "")
  )

  return(namingStructure)

}

### Things to implement

#### 'bad.names' needs a better format:
  ##    * take string or function
  ##    * better formal name

### Full transparency
  ## Just save the table?
## What's the workflow? You can't really do this in markdown, can you?
## Ah but maybe a dput-esque approach?
## Have the whole thing spit out a .rmd?
